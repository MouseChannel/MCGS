#version 460
#extension GL_EXT_debug_printf : enable
#include "DataStruct.h"
layout(local_size_x = 256) in;
layout(binding = 0) buffer Info
{
    uint all_count;
};
layout(std430, binding = 1) buffer _GaussianPoint
{
    GaussianPoint points[];
};

// layout(std430, set = 1, binding = 2) writeonly buffer GaussianCov3d
// {
//     //    float gaussian_cov3d[];// (N, 6)
//     mat3 gaussian_cov3d[];
// };
void main()
{
    uint id = gl_GlobalInvocationID.x;
    if (gl_GlobalInvocationID.x < all_count) {
        vec4 q = points[gl_GlobalInvocationID.x].rot;
        vec3 s = points[gl_GlobalInvocationID.x].scale;
        mat3 rot;
        float xx = q.x * q.x;
        float yy = q.y * q.y;
        float zz = q.z * q.z;
        float xy = q.x * q.y;
        float xz = q.x * q.z;
        float yz = q.y * q.z;
        float wx = q.w * q.x;
        float wy = q.w * q.y;
        float wz = q.w * q.z;
        rot[0][0] = 1.f - 2.f * (yy + zz);
        rot[0][1] = 2.f * (xy + wz);
        rot[0][2] = 2.f * (xz - wy);
        rot[1][0] = 2.f * (xy - wz);
        rot[1][1] = 1.f - 2.f * (xx + zz);
        rot[1][2] = 2.f * (yz + wx);
        rot[2][0] = 2.f * (xz + wy);
        rot[2][1] = 2.f * (yz - wx);
        rot[2][2] = 1.f - 2.f * (xx + yy);

        mat3 ss = mat3(0.f);
        ss[0][0] = s[0] * s[0];
        ss[1][1] = s[1] * s[1];
        ss[2][2] = s[2] * s[2];
        mat3 res = rot * ss * transpose(rot);
        points[id].conv3d[0] = vec4(res[0][0], res[1][0], res[2][0], 1);
        points[id].conv3d[1] = vec4(res[1][1], res[2][1], res[2][2], 1);

        // if (gl_GlobalInvocationID.x == 0) {
        //     debugPrintfEXT("message %f %f %f |%f %f %f \n",
        //                    res[0][0],
        //                    res[1][0],
        //                    res[2][0],
        //                    res[0][1],
        //                    res[1][1],
        //                    res[2][1]);
        // }
        // if (gl_GlobalInvocationID.x == 0) {
        //     debugPrintfEXT("message %f %f %f |%f %f %f \n", rot[0][0], rot[0][1], rot[0][2], rot[1][0], rot[1][1], rot[1][2]);
        // }
        // if (gl_GlobalInvocationID.x == 0) {
        //     debugPrintfEXT("message %f %f %f |%f  \n", q[0], q[1], q[2], q[3]);
        // }

        // if (gl_GlobalInvocationID.x == 0) {
        //     debugPrintfEXT("message %f %f %f |scale  %f %f %f  |%f %f %f  |%f %f %f  \n",
        //    points[gl_GlobalInvocationID.x].pos[0],
        //    points[gl_GlobalInvocationID.x].pos[1],
        //    points[gl_GlobalInvocationID.x].pos[2],
        //    points[gl_GlobalInvocationID.x].scale[0],
        //    points[gl_GlobalInvocationID.x].scale[1],
        //    points[gl_GlobalInvocationID.x].scale[2],

        //    points[gl_GlobalInvocationID.x].conv3d[0][0],
        //    points[gl_GlobalInvocationID.x].conv3d[0][1],
        //    points[gl_GlobalInvocationID.x].conv3d[0][2],
        //    points[gl_GlobalInvocationID.x].conv3d[1][0],
        //    points[gl_GlobalInvocationID.x].conv3d[1][1],
        //    points[gl_GlobalInvocationID.x].conv3d[1][2]);
        // }

        if (gl_GlobalInvocationID.x == 0) {
            debugPrintfEXT(
                "message %f %f %f  | %f %f %f | %f %f %f  |%f %f %f  \n",
                float(points[id].sh[0][0]),
                float(points[id].sh[0][1]),
                float(points[id].sh[0][2]),
                float(points[id].sh[0][3]),
                float(points[id].sh[1][0]),
                float(points[id].sh[1][1]),
                float(points[id].sh[1][2]),
                float(points[id].sh[1][3]),
                float(points[id].sh[2][0]),
                float(points[id].sh[2][1]),
                float(points[id].sh[2][2]),
                float(points[id].sh[2][3]));
        }
    }
}
