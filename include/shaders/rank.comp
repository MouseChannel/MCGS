#version 460 core
#include "DataStruct.h"
#extension GL_EXT_debug_printf : enable

layout(std430, binding = e_gaussian_raw_point) buffer _GaussianPoint
{
    GaussianPoint points[];
};

layout(binding = e_point_count) buffer Info
{
    uint all_count;
};
layout(std430, binding = e_indir_cmd) buffer DrawIndirect
{

    // IndexedIndirectCommand indirectDrawcmd;
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};
layout(push_constant, std430) uniform PushConstants
{
    mat4 model;
};
layout(binding = e_camera) uniform Camera
{
    mat4 projection;
    mat4 view;
    vec3 camera_position;
    // float pad0;
    // uvec2 screen_size; // (width, height)
};

layout(std430, binding = e_instance_key) writeonly buffer InstanceKey
{
    uint key[];
};

layout(std430, binding = e_instance_value) writeonly buffer InstanceIndex
{
    uint index[];
};
layout(local_size_x = 256) in;
void main()
{
    uint id = gl_GlobalInvocationID.x;
    if (id >= all_count)
        return;

    vec4 pos = vec4(points[id].pos, 1.f);
    pos = projection * view * model * pos;
    pos = pos / pos.w;
    float depth = pos.z;
    // valid only when center is inside NDC clip space.
    if (abs(pos.x) <= 1.f && abs(pos.y) <= 1.f && pos.z >= 0.f && pos.z <= 1.f) {
        // indirectDrawcmd.indexCount = atomicAdd(indirectDrawcmd.indexCount, 1);
        uint instance_index = atomicAdd(indexCount, 1);
        key[instance_index] = floatBitsToUint(1.f - depth);
        index[instance_index] = id;
        // debugPrintfEXT("message  %d %d\n", key[indirectDrawcmd.indexCount], indirectDrawcmd.indexCount);

        // if (indirectDrawcmd.indexCount == 0) {
        //     debugPrintfEXT("message  %f %d\n", key[indirectDrawcmd.indexCount], index[indirectDrawcmd.indexCount]);
        // }
    }
}